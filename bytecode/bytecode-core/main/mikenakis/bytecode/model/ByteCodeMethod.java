package mikenakis.bytecode.model;

import mikenakis.bytecode.kit.BufferReader;
import mikenakis.bytecode.kit.BufferWriter;
import mikenakis.bytecode.model.constants.value.Mutf8ValueConstant;
import mikenakis.bytecode.model.descriptors.MethodPrototype;
import mikenakis.bytecode.reading.ReadingConstantPool;
import mikenakis.bytecode.writing.Interner;
import mikenakis.bytecode.writing.WritingConstantPool;
import mikenakis.bytecode.writing.WritingLocationMap;
import mikenakis.java_type_model.MethodDescriptor;
import mikenakis.kit.annotations.ExcludeFromJacocoGeneratedReport;
import mikenakis.kit.collections.FlagEnum;
import mikenakis.kit.collections.FlagSet;

import java.lang.reflect.Method;
import java.util.Map;
import java.util.Optional;

/**
 * Represents a method.
 *
 * @author michael.gr
 */
public final class ByteCodeMethod extends ByteCodeMember
{
	public enum Modifier
	{
		Public, Private, Protected, Static, Final, Synchronized, Bridge, Varargs, Native, Abstract, Strict, Synthetic
	}

	public static final FlagEnum<Modifier> modifierEnum = FlagEnum.of( Modifier.class, //
		Map.entry( Modifier.Public       /**/, 0x0001 ), // ACC_PUBLIC       = 0x0001 -- Declared public; may be accessed from outside its package.
		Map.entry( Modifier.Private      /**/, 0x0002 ), // ACC_PRIVATE      = 0x0002 -- Declared private; accessible only within the defining class.
		Map.entry( Modifier.Protected    /**/, 0x0004 ), // ACC_PROTECTED    = 0x0004 -- Declared protected; may be accessed within subclasses.
		Map.entry( Modifier.Static       /**/, 0x0008 ), // ACC_STATIC       = 0x0008 -- Declared static.
		Map.entry( Modifier.Final        /**/, 0x0010 ), // ACC_FINAL        = 0x0010 -- Declared final; must not be overridden (ยง5.4.5).
		Map.entry( Modifier.Synchronized /**/, 0x0020 ), // ACC_SYNCHRONIZED = 0x0020 -- Declared synchronized; invocation is wrapped by a monitor use.
		Map.entry( Modifier.Bridge       /**/, 0x0040 ), // ACC_BRIDGE       = 0x0040 -- A bridge method, generated by the compiler.
		Map.entry( Modifier.Varargs      /**/, 0x0080 ), // ACC_VARARGS      = 0x0080 -- Declared with variable number of arguments.
		Map.entry( Modifier.Native       /**/, 0x0100 ), // ACC_NATIVE       = 0x0100 -- Declared native; implemented in a language other than Java.
		Map.entry( Modifier.Abstract     /**/, 0x0400 ), // ACC_ABSTRACT     = 0x0400 -- Declared abstract; no implementation is provided.
		Map.entry( Modifier.Strict       /**/, 0x0800 ), // ACC_STRICT       = 0x0800 -- Declared strictfp; floating-point mode is FP-strict.
		Map.entry( Modifier.Synthetic    /**/, 0x1000 )  // ACC_SYNTHETIC    = 0x1000 -- Declared synthetic; not present in the source code.
	);

	public static ByteCodeMethod read( BufferReader bufferReader, ReadingConstantPool constantPool )
	{
		FlagSet<Modifier> methodModifiers = modifierEnum.fromBits( bufferReader.readUnsignedShort() );
		Mutf8ValueConstant nameConstant = constantPool.getConstant( bufferReader.readUnsignedShort() ).asMutf8ValueConstant();
		Mutf8ValueConstant descriptorConstant = constantPool.getConstant( bufferReader.readUnsignedShort() ).asMutf8ValueConstant();
		AttributeSet attributes = AttributeSet.read( bufferReader, constantPool, Optional.empty() );
		return of( methodModifiers, nameConstant, descriptorConstant, attributes );
	}

	public static ByteCodeMethod of( FlagSet<Modifier> modifiers, Method method )
	{
		return of( modifiers, MethodPrototype.of( method ) );
	}

	public static ByteCodeMethod of( FlagSet<Modifier> modifiers, MethodPrototype methodPrototype )
	{
		return new ByteCodeMethod( modifiers, Mutf8ValueConstant.of( methodPrototype.methodName ), Mutf8ValueConstant.of( ByteCodeHelpers.descriptorStringFromMethodDescriptor( methodPrototype.descriptor ) ), AttributeSet.of() );
	}

	public static ByteCodeMethod of( FlagSet<Modifier> modifiers, Mutf8ValueConstant methodNameConstant, Mutf8ValueConstant methodDescriptorStringConstant, AttributeSet attributeSet )
	{
		return new ByteCodeMethod( modifiers, methodNameConstant, methodDescriptorStringConstant, attributeSet );
	}

	public final FlagSet<Modifier> modifiers;
	private final Mutf8ValueConstant methodNameConstant;
	private final Mutf8ValueConstant methodDescriptorStringConstant;
	public final AttributeSet attributeSet;

	private ByteCodeMethod( FlagSet<Modifier> modifiers, Mutf8ValueConstant methodNameConstant, Mutf8ValueConstant methodDescriptorStringConstant, AttributeSet attributeSet )
	{
		this.modifiers = modifiers;
		this.methodNameConstant = methodNameConstant;
		this.methodDescriptorStringConstant = methodDescriptorStringConstant;
		this.attributeSet = attributeSet;
	}

	public boolean isMatch( MethodPrototype methodPrototype )
	{
		if( !name().equals( methodPrototype.methodName ) )
			return false;
		return descriptor().equals( methodPrototype.descriptor );
	}

	@Override public String name() { return methodNameConstant.stringValue(); }
	public MethodDescriptor descriptor() { return ByteCodeHelpers.methodDescriptorFromDescriptorString( methodDescriptorStringConstant.stringValue() ); }
	public MethodPrototype prototype() { return MethodPrototype.of( name(), descriptor() ); }
	@ExcludeFromJacocoGeneratedReport @Override public String toString() { return "accessFlags = " + modifiers + ", name = " + methodNameConstant + ", descriptor = " + methodDescriptorStringConstant; }

	public void intern( Interner interner )
	{
		methodNameConstant.intern( interner );
		attributeSet.intern( interner );
		methodDescriptorStringConstant.intern( interner );
	}

	public void write( BufferWriter bufferWriter, WritingConstantPool constantPool, Optional<WritingLocationMap> locationMap )
	{
		bufferWriter.writeUnsignedShort( modifiers.getBits() );
		bufferWriter.writeUnsignedShort( constantPool.getConstantIndex( methodNameConstant ) );
		bufferWriter.writeUnsignedShort( constantPool.getConstantIndex( methodDescriptorStringConstant ) );
		attributeSet.write( bufferWriter, constantPool, locationMap );
	}
}

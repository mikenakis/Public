package mikenakis.bytecode.model;

import mikenakis.bytecode.model.constants.value.Mutf8ValueConstant;
import mikenakis.bytecode.model.descriptors.MethodPrototype;
import mikenakis.bytecode.writing.ConstantWriter;
import mikenakis.bytecode.writing.Interner;
import mikenakis.java_type_model.MethodDescriptor;
import mikenakis.kit.annotations.ExcludeFromJacocoGeneratedReport;
import mikenakis.kit.collections.FlagEnum;
import mikenakis.kit.collections.FlagSet;

import java.util.Map;

/**
 * Represents a method.
 *
 * @author Michael Belivanakis (michael.gr)
 */
public final class ByteCodeMethod extends ByteCodeMember
{
	public enum Modifier
	{
		Public, Private, Protected, Static, Final, Synchronized, Bridge, Varargs, Native, Abstract, Strict, Synthetic
	}

	public static final FlagEnum<Modifier> modifierEnum = FlagEnum.of( Modifier.class, //
		Map.entry( Modifier.Public       /**/, 0x0001 ), // ACC_PUBLIC       = 0x0001 -- Declared public; may be accessed from outside its package.
		Map.entry( Modifier.Private      /**/, 0x0002 ), // ACC_PRIVATE      = 0x0002 -- Declared private; accessible only within the defining class.
		Map.entry( Modifier.Protected    /**/, 0x0004 ), // ACC_PROTECTED    = 0x0004 -- Declared protected; may be accessed within subclasses.
		Map.entry( Modifier.Static       /**/, 0x0008 ), // ACC_STATIC       = 0x0008 -- Declared static.
		Map.entry( Modifier.Final        /**/, 0x0010 ), // ACC_FINAL        = 0x0010 -- Declared final; must not be overridden (ยง5.4.5).
		Map.entry( Modifier.Synchronized /**/, 0x0020 ), // ACC_SYNCHRONIZED = 0x0020 -- Declared synchronized; invocation is wrapped by a monitor use.
		Map.entry( Modifier.Bridge       /**/, 0x0040 ), // ACC_BRIDGE       = 0x0040 -- A bridge method, generated by the compiler.
		Map.entry( Modifier.Varargs      /**/, 0x0080 ), // ACC_VARARGS      = 0x0080 -- Declared with variable number of arguments.
		Map.entry( Modifier.Native       /**/, 0x0100 ), // ACC_NATIVE       = 0x0100 -- Declared native; implemented in a language other than Java.
		Map.entry( Modifier.Abstract     /**/, 0x0400 ), // ACC_ABSTRACT     = 0x0400 -- Declared abstract; no implementation is provided.
		Map.entry( Modifier.Strict       /**/, 0x0800 ), // ACC_STRICT       = 0x0800 -- Declared strictfp; floating-point mode is FP-strict.
		Map.entry( Modifier.Synthetic    /**/, 0x1000 )  // ACC_SYNTHETIC    = 0x1000 -- Declared synthetic; not present in the source code.
	);

	public static ByteCodeMethod of( FlagSet<Modifier> modifiers, MethodPrototype methodPrototype )
	{
		return new ByteCodeMethod( modifiers, Mutf8ValueConstant.of( methodPrototype.methodName ), Mutf8ValueConstant.of( ByteCodeHelpers.descriptorStringFromMethodDescriptor( methodPrototype.descriptor ) ), AttributeSet.of() );
	}

	public static ByteCodeMethod of( FlagSet<Modifier> modifiers, Mutf8ValueConstant methodNameConstant, Mutf8ValueConstant methodDescriptorStringConstant, AttributeSet attributeSet )
	{
		return new ByteCodeMethod( modifiers, methodNameConstant, methodDescriptorStringConstant, attributeSet );
	}

	public final FlagSet<Modifier> modifiers;
	private final Mutf8ValueConstant methodNameConstant;
	private final Mutf8ValueConstant methodDescriptorStringConstant;
	public final AttributeSet attributeSet;

	private ByteCodeMethod( FlagSet<Modifier> modifiers, Mutf8ValueConstant methodNameConstant, Mutf8ValueConstant methodDescriptorStringConstant, AttributeSet attributeSet )
	{
		this.modifiers = modifiers;
		this.methodNameConstant = methodNameConstant;
		this.methodDescriptorStringConstant = methodDescriptorStringConstant;
		this.attributeSet = attributeSet;
	}

	public boolean isMatch( MethodPrototype methodPrototype )
	{
		if( !name().equals( methodPrototype.methodName ) )
			return false;
		return descriptor().equals( methodPrototype.descriptor );
	}

	@Override public String name() { return methodNameConstant.stringValue(); }
	public MethodDescriptor descriptor() { return ByteCodeHelpers.methodDescriptorFromDescriptorString( methodDescriptorStringConstant.stringValue() ); }
	public MethodPrototype prototype() { return MethodPrototype.of( name(), descriptor() ); }
	@ExcludeFromJacocoGeneratedReport @Override public String toString() { return "accessFlags = " + modifiers + ", name = " + methodNameConstant + ", descriptor = " + methodDescriptorStringConstant; }

	public void intern( Interner interner )
	{
		methodNameConstant.intern( interner );
		attributeSet.intern( interner );
		methodDescriptorStringConstant.intern( interner );
	}

	public void write( ConstantWriter constantWriter )
	{
		constantWriter.writeUnsignedShort( modifiers.getBits() );
		constantWriter.writeUnsignedShort( constantWriter.getConstantIndex( methodNameConstant ) );
		constantWriter.writeUnsignedShort( constantWriter.getConstantIndex( methodDescriptorStringConstant ) );
		attributeSet.write( constantWriter );
	}
}
